{"./":{"url":"./","title":"本书简介","keywords":"","body":"本书简介 "},"page/1010.html":{"url":"page/1010.html","title":"速查","keywords":"","body":"速查 "},"page/1011.html":{"url":"page/1011.html","title":"简介","keywords":"","body":"简介 "},"page/1012.html":{"url":"page/1012.html","title":"发展","keywords":"","body":"发展 ​ Java是1995年6月由Sun公司引进到我们这个世界的革命性的编程语言。1990年Sun公司成立了由James Gosling领导的开发小组，开始致力于开发一种可移植的、跨平台的语言，该语言能生成正确运行于各种操作系统、各种CPU芯片上的代码。他们的精心专研和努力促成了Java语言的诞生。 印度尼西亚有一个重要的盛产咖啡的岛屿叫Java，中文译名为爪哇，开发人员为这种新的语言起名为Java，其寓意是为世人端上一杯热咖啡。 网络地位 Java的平台无关性让Java成为编写网络应用程序的佼佼者，而且Java也提供了许多以网络应用为核心的技术，使得Java特别适合于网络应用软件的设计与开发。 语言地位 是一门很好的面向对象语言,通过学习Java语言可以学习怎样使用对象来完成某些任务、掌握面向对象编程的基本思想. 需求地位 IT行业对Java人才的需求正在不断的增长，掌握Java语言及其相关技术意味着较好的就业前景和工作酬金。 "},"page/1140.html":{"url":"page/1140.html","title":"原理","keywords":"","body":"原理 Java虚拟机与字节码 ​ Java语言提供的编译器不针对特定的操作系统和CPU芯片进行编译，而是针对Java虚拟机把Java源程序编译成称为字节码的“中间代码”可以被Java虚拟机直接识别、执行的一种由0，1组成的序列代码。 ​ 字节码并不是机器指令，因为它不和特定的平台相关，不能被任何平台直接识别、执行。Java针对不同平台提供的Java虚拟机的字节码指令都是相同的，Java虚拟机负责将字节码翻译成虚拟机所在平台的机器码，并让当前平台运行该机器码，如下图所示 java生成的字节码文件不依赖于平台 Java程序的开发步骤 开发步骤： ​ 1) 编写源文件:扩展名必须是 .java。 2) 编译Java源程序:用Java编译器（javac.exe）编译源文件，得到字节码文件。 3) 运行Java程序:使用Java解释器（java.exe）来解释执行字节码文件。 编写与保存源文件 编写源文件 源文件的编写与保存 Java应用程序的源文件是由若干个书写形式互相独立的类组成 //源文件Hello.java是由Hello和Student的类组成。 package app1_1;// Netbeans建立项目时增加的部分 public class Hello { public static void main (String args[]) { System.out.println(\"大家好!\"); System.out.println(\"Nice to meet you\"); Student stu = new Student(); stu.speak(\"We are students\"); } } class Student { public void speak(String s) { System.out.println(s); } } 使用一个文本编辑器，如Edit或记事本编写上述例子给出的源文件。 Java源程序中语句所涉及到的小括号及标点符号都是英文状态下输入的括号和标点符号，比如“大家好!”中的引号必须是英文状态下的引号，而字符串里面的符号不受汉字符或英文字符的限制。 保存源文件 如果源文件中有多个类，那么只能有一个类是public类； 如果有一个类是public类，那么源文件的名字必须与这个类的名字完全相同，扩展名是java； 如果源文件没有public类，那么源文件的名字只要和某个类的名字相同，并且扩展名是java就可以了。 上述例子1中的源文件必须命名为Hello.java。我们将Hello.java保存到C:\\chapter1文件夹中。 编译 编译器（javac） 进入逻辑分区C的chapter1目录中，使用编译器javac编译源文件 $ javac Hello.java 运行 1.应用程序的主类 一个Java应用程序必须有一个类含有public static void main（String args[ ]） 方法，称这个类是应用程序的主类。 2．解释器（java） ​ 使用Java虚拟机中的Java解释器（java.exe）来解释执行其字节码文件。 ​ Java应用程序总是从主类的main方法开始执行。 因此，需进入主类字节码所在目录，比如C:\\chapter1，然后使用Java解释器（java.exe）运行主类的字节码. $ java Hello Hello是 public static void main（String args[ ]） 方法所在的类名，不需要.java后缀 Java反编译和文档生成器 ​ JDK提供的反编译器是javap.exe（也有针对Java的许多商业反编译软件，例如dj-gui反编译）。 如果想反编译例子1中的Hello.class，可使用javap命令：javap Hello.class ，例如 $ javap Hello.class 如果想反编译类库中的Date类（其包名是java.util）Date.class，可使用javap命令：javap java.util.Date.class，例如：javap java.util.Date.class 反编译器javap.exe可以将字节码反编译为源码，以便查看源码类中的public方法名字和public成员变量的名字。 例如：javap java.awt.Button 使用javadoc.exe可以制做源文件类结构的html格式文档。 例如： javadoc Example.java jar文件 可以使用jar.exe命令把一些类的字节码文件压缩成一个jar文件，然后将这个jar文件存放到Java运行环境的扩展中，即将该jar文件存放在JDK安装目录的jre\\lib\\ext文件夹中。这样，Java应用程序就可以使用这个jar文件中的类来创建对象了 "},"page/1013.html":{"url":"page/1013.html","title":"配置","keywords":"","body":"配置 安装jdk 三种平台简介 ​ 目前Java平台主要分为下列3个版本: ​ （1）Java SE（曾称为J2SE）称为Java标准版或Java 标准平台. （2）Java EE（曾称为J2EE）称为Java企业版或Java企业平台. ​ （3）Java ME（曾称为J2ME）称为Java微型版或Java小型平台. ​ 无论上述哪种Java运行平台都包括了相应的Java虚拟机（Java Virtual Machine），虚拟机负责将字节码文件（包括程序使用的类库中的字节码）加载到内存，然后采用解释方式来执行字节码文件，即根据相应平台的机器指令翻译一句执行一句。 "},"page/1014.html":{"url":"page/1014.html","title":"基础","keywords":"","body":"基础 "},"page/1119.html":{"url":"page/1119.html","title":"标识符","keywords":"","body":"标识符 用来标识类名、变量名、方法名、类型名、数组名、文件名的有效字符序列称为标识符，简单地说，标识符就是一个名字 "},"page/1120.html":{"url":"page/1120.html","title":"关键字","keywords":"","body":"关键字 关键字就是具有特定用途或被赋予特定意义的一些单词，不可以把关键字作为标识符来用 。 例如： boolean、byte、short、int、float、double、char、if、else等。 关键字都是小写的。遇到大写肯定不是关键字。 "},"page/1121.html":{"url":"page/1121.html","title":"预定义标识符","keywords":"","body":"预定义标识符 "},"page/1122.html":{"url":"page/1122.html","title":"用户自定义标识符","keywords":"","body":"用户自定义标识符 自定义标识符由字母、下划线、美元符号和数字组成，长度不受限制。 自定义标识符的第一个字符不能是数字字符。 标识符不能是关键字。 自定义标识符不能是true、false和null（尽管true、false和null不是关键字）。 "},"page/1115.html":{"url":"page/1115.html","title":"行与缩进","keywords":"","body":"空格与空行 "},"page/1117.html":{"url":"page/1117.html","title":"大小写","keywords":"","body":"大小写 "},"page/1118.html":{"url":"page/1118.html","title":"注释","keywords":"","body":"注释 编译器忽略注释内容，注释的目的是有利于代码的维护和阅读，因此给代码增加注释是一个良好的编程习惯。 Java支持两种格式的注释：单行注释和多行注释 单行注释使用“//”表示单行注释的开始，即该行中从“//”开始的后续内容为注释 . 多行注释的使用“/”表示注释的开始，以“/”表示注释结束 . "},"page/1133.html":{"url":"page/1133.html","title":"编码","keywords":"","body":"编码 "},"page/1116.html":{"url":"page/1116.html","title":"语句结束","keywords":"","body":"语句结束 "},"page/1023.html":{"url":"page/1023.html","title":"风格","keywords":"","body":"风格 Allmans风格 ​ Allmans风格也称“独行”风格，即左、右大括号各自独占一行，如下列代码所示意 .当代码量较小时适合使用“独行”风格，代码布局清晰，可读性强 class Allmans { public static void main(String args[]) { int sum=0,i=0,j=0; for(i=1;i Kernighan风格 ​ Kernighan风格也称“行尾”风格，即左大括号在上一行的行尾，而右大括号独占一行，如下列代码所示意。当代码量较大时不适合使用“独行”风格，因为该风格将导致代码的左半部分出现大量的左、右大括号，导致代码清晰度下降，这时应当使用“行尾”风格 。 class Kernighan { public static void main(String args[]) { int sum=0,i=0,j=0; for(i=1;i "},"page/1024.html":{"url":"page/1024.html","title":"数据类型","keywords":"","body":"数据类型 "},"page/1134.html":{"url":"page/1134.html","title":"组成","keywords":"","body":"组成 "},"page/1125.html":{"url":"page/1125.html","title":"基本数据类型","keywords":"","body":"基本数据类型 有8种基本数据类型 boolean、byte、short、int、long、float、double、char 8种基本数据类型习惯上可分为以下四大类型 逻辑类型：boolean 整数类型：byte、short、int、long 字符类型：char 浮点类型：float、double "},"page/1069.html":{"url":"page/1069.html","title":"数值型","keywords":"","body":"数值型 Java提供了数值型数据的最大值与最小值的标识符及常量值 数值型常量的特殊值代码 数据类型 所在的类 最小值代码 最大值代码 byte Java.lang.Byte Byte.MIN_VALUE Byte.MAX_VALUE short Java.lang.Short Short.MIN_VALUE Short.MAX_VALUE int Java.lang.Integer Integer.MIN_VALUE Integer.MAX_VALUE long Java.lang.Long Long.MIN_VALUE Long.MAX_VALUE float Java.lang.Float Float.MIN_VALUE Float.MAX_VALUE double Java.lang.Double Double.MIN_VALUE Double.MAX_VALUE "},"page/1070.html":{"url":"page/1070.html","title":"整型","keywords":"","body":"整型 int 型 变量：使用关键字int来声明int型变量,声明时也可以赋给初值. 例如： int x= 12,平均=9898,jiafei; 常量：int型常量共有三种表示方法： ​ 十进制： 123，6000（十进制） ​ 八进制： 077（八进制，是零开头）； ​ 十六进制： 0x3ABC（十六进制，是零和x开头） 对于int型变量，内存分配给4个字节（byte）,占32位. byte 型 变量：使用关键字byte来声明byte 型变量. 例如： byte x= -12, tom=28, 漂亮=98; 常量：一定范围内的int型常量赋值给byte型变量. 对于byte型内存分配给1个字节，占8位 . short 型 变量：使用关键字short来声明short型变量。 例如： short x=12,y=1234; 常量：和byte型类似，Java中也不存在short型常量的表示法，但可以把一定范围内的int型常量赋值给short型变量。 对于short型变量，内存分配给2个字节，占16位. long 型 变量：使用关键字long来声明long型变量。 常量：long型常量用后缀L来表示， 例如108L(十进制)、07123L(八进制)、 0x3ABCL(十六进制) 。 例如： long width=12L,height=2005L,length; 对于long型变量，内存分配给8个字节，占64位。 "},"page/1071.html":{"url":"page/1071.html","title":"浮点型","keywords":"","body":"浮点型 float型 常量：453.54F(小数表示法)，2e40f(2乘10的40次方，指数表示法). 变量：使用关键字float来声明float型变量， 例如：float x=22.76f,tom=1234.987f,weight=1e-12F; 精度:float变量在存储时保留8位有效数字。 对于float型变量，内存分配给4个字节，占32位。 注意：float常量后面必须要有后缀f或F。 double 型 常量：238.539d，231.987(小数表示法)，1e-90(1乘10的-90次方，指数表示法).对于double常量,后缀有“d”或“D”，但允许省略后缀. 变量：使用关键字double来声明double型变量， 例如：double height=23.345,width=34.56D,length=1e12; 对于double型变量，内存分配给8个字节，占64位 。 精度:double变量在存储double型数据时保留16位有效数字，实际精度取决于具体数值。 注意：一个具有小数部分的数据的缺省类型是double而不是float。所以float常量后面必须要有后缀“f”或“F”。 "},"page/1072.html":{"url":"page/1072.html","title":"字符型","keywords":"","body":"字符型 char类型 常量：‘A’，‘b’，‘?’，‘!’，‘9’，‘好’，‘\\t’，‘き’，‘モ’等，即用单引号扩起的Unicode表中的一个字符。 变量： 使用关键字char来声明char型变量，对于char型变量，内存分配给2个字节，占16位 例如：char ch=‘A’,home=‘家’,handsome=‘酷’; Java语言使用Unicode标准字符集，最多可以识别65536个字符 转意字符常量 有些字符（如回车符）不能通过键盘输入到字符串或程序中，就需要使用转意字符常量, 例如：\\n(换行), \\b(退格),\\t(水平制表),\\‘(单引号), \\“(双引号),\\\\(反斜线)等。 常用的转义字符 转义字符 所代表的意义 \\f 换页(Form feed)，走纸到下一页。 \\b 退格(Backspace)，后退一格。 \\n 换行(New line)，将光标移到下一行的开始。 \\r 回车(Carriage return)，将光标移到当前行的行首，但不移到下一行。 \\t 横向跳格(Tab)，将光标移到下一个制表符位置。 \\ 反斜线字符(Backslash)，输出一个反斜杠。 \\' 单引号字符(Single quote)，输出一个单引号。 \\\" 双引号字符(Double quote)，输出一个双引号。 \\uxxxx 1到4位十六进制数(xxxx)所表示的unicode字符。 \\ddd 1到3位八制数(ddd)所表示的unicode字符，范围在八进制的000～377之间。 "},"page/1073.html":{"url":"page/1073.html","title":"布尔型","keywords":"","body":"布尔型(逻辑类型) 变量 使用关键字boolean来声明逻辑变量，声明时也可以赋给初值。 常量 true、false boolean x,ok=true,关闭=false; "},"page/1074.html":{"url":"page/1074.html","title":"引用型数据类型","keywords":"","body":"引用型数据类型 "},"page/1075.html":{"url":"page/1075.html","title":"类","keywords":"","body":"类与程序的基本结构 一个Java应用程序（也称为一个工程）是由若干个类所构成，这些类可以在一个源文件中，也可以分布在若干个源文件中 Java应用程序从主类的main方法开始执行。在编写一个Java应用程序时，可以编写若干个Java源文件，每个源文件编译后产生一个类的字节码文件。 类定义 Java语言是面向对象语言，它的源程序是由若干个类组成，源文件是扩展名为.java的文本文件。 类是Java语言中最重要的“数据类型”，类声明的变量被称作对象，即类是用来创建对象的模板。 类的实现包括两部分：类声明和类体。 类（主类，万物类） 主类（可以没成员变量，主函数调用万物对象完成功能） 万物类（自己的属性，自己的行为） 包（区分不同空间的类） 写类的目的是为了描述一类事物共有的属性和功能。 //类基本格式 class 类名{ 类体内容 } //类的定义包括两个部分：类声明 和 类体 //其中：class是关键字，用来定义类。“class 类名”是类的声明部分，类名必须是合法的Java标识符。两个大括号以及之间的内容是类体。 类声明 class 类名 //以下是两个类声明的例子。 class People { … } class 植物 { … } //如：class People”和“class 植物”称作类声明；“People”和“动物”分别是类名。 class 类名 是类的声明部分，class是关键字用来定义类，类名是java标识符 给类命名时，遵守下列编程风格(这不是语法要求,但应当遵守): 1.如果类名使用拉丁字母，那么名字的首字母使用大写字母。 2.类名最好容易识别、见名知意。当类名由几个“单词”复合而成时，每个单词的首字母使用大写。 类体 类声明之后的一对大括号“{”，“}”以及它们之间的内容称作类体，大括号之间的内容称作类体的内容。 class 类名{ //类体内容： 变量声明//用来存储属性的值（体现对象的属性） 方法的定义//方法可以对类中声明的变量进行操作，即给出算法（函数，体现行为） } 类体的内容由两部分构：一部分是变量的声明，用来刻画属性；另一部分是方法的定义，用来刻画行为功能。 class 类名{ //类体内容： //变量声明: 成员变量=实例变量=实例=实例成员 static 成员变量=类变量=静态变量 //方法的定义: 实例方法=[修饰符] 类型 方法名称1(参数){ 构造函数=方法名称1() 局部变量 } 类方法=static 实例方法=static 类型 方法名称2(参数){ 构造函数=方法名称2() 局部变量 } } class Lader { float above; //梯形的上底(变量声明) float bottom; //梯形的下底(变量声明) float height; //梯形的高(变量声明) float area; //梯形的面积(变量声明) float computerArea() { //计算面积(方法) area = (above+bottom)*height/2.0f; return area; } void setHeight(float h) { //修改高(方法) height = h;//set---get---上面的 } } 类使用 创建对象 创建一个对象包括对象的声明和为对象分配变量两个步骤。 对象的声明 一般格式为： 类的名字 对象名字; //如： XiyoujiRenwu zhubajie; 为声明的对象分配变量 使用new运算符和类的构造方法为声明的对象分配变量，并返回一个引用值给对象名称。即创建对象。如果类中没有构造方法，系统会调用默认的构造方法，默认的构造方法是无参数的，且方法体中没有语句。 对象名字 = new 类的构造方法(对象的构造参数)； zhubajie = new XiyoujiRenwu(); 当用类创建一个对象时，类中的成员变量被分配内存空间，这些内存空间称作该对象的实体或对象的变量，而对象中存放着引用值。 一个类创建的两个对象，如果具有相同的引用，那么就具有完全相同的实体。 class Point{ double x,y; Point(double x,double y){ this.x=x; this.y=y; } } //使用Point类创建了两个对象p1，p2： Point p1 = new Point (5,15); Point p2 = new Point(8,18); 使用对象 对象创建成功后，可以操作类中的变量和方法： 1．对象操作自己的变量（体现对象的属性） ​ 通过使用运算符“.” 对象操作自己的变量（对象的属性）。 2．对象调用类中的方法（体现对象的行为） ​ 对象创建之后，可以使用点运算符“.”调用创建它的类中的方法，从而产生一定的行为（功能）。 当对象调用变量时，是指调用分配给该对象自己的变量。 类中的方法可以操作成员变量；当对象调用方法时，方法中出现的成员变量就是指分配给该对象的那个变量。 "},"page/1142.html":{"url":"page/1142.html","title":"类定义","keywords":"","body":"类定义 Java语言是面向对象语言，它的源程序是由若干个类组成，源文件是扩展名为.java的文本文件。 类是Java语言中最重要的“数据类型”，类声明的变量被称作对象，即类是用来创建对象的模板。 类的实现包括两部分：类声明和类体。 类（主类，万物类） 主类（可以没成员变量，主函数调用万物对象完成功能） 万物类（自己的属性，自己的行为） 包（区分不同空间的类） 写类的目的是为了描述一类事物共有的属性和功能。 //类基本格式 class 类名{ 类体内容 } //类的定义包括两个部分：类声明 和 类体 //其中：class是关键字，用来定义类。“class 类名”是类的声明部分，类名必须是合法的Java标识符。两个大括号以及之间的内容是类体。 类体的内容由两部分构成： ​ 一部分是变量的声明，另一部分是方法的定义。 定义类需要注意的地方： 1)对成员变量的操作只能放在方法中，方法可以对成员变量和该方法体中声明的局部变量进行操作。在声明成员变量时可以同时赋予初值，但是不可以在类体中有单独的赋值语句，但局部变量必须赋初值。 2)实例方法既能对类变量操作也能对实例变量操作，而类方法只能对类变量进行操作。 3)一个类中的方法可以2互相调用，实例方法可以调用该类中的其他方法，类中的类方法只能调用该类的类方法。 class A { int a=12; //ok int b; b=12; //error } "},"page/1143.html":{"url":"page/1143.html","title":"类声明","keywords":"","body":"类声明 类声明 class 类名 //以下是两个类声明的例子。 class People { … } class 植物 { … } //如：class People”和“class 植物”称作类声明；“People”和“动物”分别是类名。 class 类名 是类的声明部分，class是关键字用来定义类，类名是java标识符 给类命名时，遵守下列编程风格(这不是语法要求,但应当遵守): 1.如果类名使用拉丁字母，那么名字的首字母使用大写字母。 2.类名最好容易识别、见名知意。当类名由几个“单词”复合而成时，每个单词的首字母使用大写。 "},"page/1144.html":{"url":"page/1144.html","title":"类体","keywords":"","body":"类体 类体 类声明之后的一对大括号“{”，“}”以及它们之间的内容称作类体，大括号之间的内容称作类体的内容。 class 类名{ //类体内容： 变量声明//用来存储属性的值（体现对象的属性） 方法的定义//方法可以对类中声明的变量进行操作，即给出算法（函数，体现行为） } 类体的内容由两部分构：一部分是变量的声明，用来刻画属性；另一部分是方法的定义，用来刻画行为功能。 class 类名{ //类体内容： //变量声明: 成员变量=实例变量=实例=实例成员 static 成员变量=类变量=静态变量 //方法的定义: 实例方法=[修饰符] 类型 方法名称1(参数){ 构造函数=方法名称1() 局部变量 } 类方法=static 实例方法=static 类型 方法名称2(参数){ 构造函数=方法名称2() 局部变量 } } class Lader { float above; //梯形的上底(变量声明) float bottom; //梯形的下底(变量声明) float height; //梯形的高(变量声明) float area; //梯形的面积(变量声明) float computerArea() { //计算面积(方法) area = (above+bottom)*height/2.0f; return area; } void setHeight(float h) { //修改高(方法) height = h;//set---get---上面的 } } "},"page/1145.html":{"url":"page/1145.html","title":"变量声明","keywords":"","body":"变量声明 class 类名{ //类体内容： //变量声明: 成员变量=实例变量=实例=实例成员 static 成员变量=类变量=静态变量 //方法的定义: 实例方法=[修饰符] 类型 方法名称1(参数|也是局部变量){ 构造函数=方法名称1() 局部变量 } 类方法=static 实例方法=static 类型 方法名称2(参数|也是局部变量){ 构造函数=方法名称2() 局部变量 } } 成员变量与局部变量 成员变量 局部变量 别名 实例变量、实例、实例成员 static修饰时 类变量、静态变量 位置 类体中变量定义部分所定义的变量被称为类的成员变量。 在方法体中定义的变量和方法的参数被称为局部变量。 有效性 成员变量在整个类内都有效，其有效性与它在类体中书写的先后位置无关。//和方法同级 局部变量只在定义它的方法内有效1. 参数--整个方法有效2.方法中定义--在方法中且方法中声明位置之后有效3.局部变量声明在复合语句中--在该复合语句内且在声明位置之后有效 默认值 成员变量在定义时有默认值 局部变量在定义时没有默认值 有效性--局部优先 如果局部变量的名字与成员变量的名字相同，则成员变量被隐藏，即该成员变量在这个方法内暂时失效。 如果想在该方法中使用被隐藏的成员变量，必须使用关键字this class Tom { int x = 10,y; void f() { int x = 5; y = x+x; //y得到的值是10，不是20。 //如果方法f 中没有“int x=5;”，y的值将是20 } } //------------------------------ class Tom { int x = 10,y; void f() { int x = 5; y = x+this.x; //y得到的值是15 }} //this当前所在区域 public class test { int a = 10, b = 0; //成员变量，在整个类中有效 public static void main(String[] args) { //m = 9; //非法,因为m声明位置在后面,声明位置之后才有效 int m = 10, sum = 0; //局部变量，在函数中且在声明位置之后有效 if (m > 9) { // z = 2 * m + z; //非法,因为z声明位置在后面,声明位置之后才有效 int z = 10; //z仅仅在该复合语句后面有效 z = 2 * m + z; //合法，局部变量，在复合语句中且在声明位置之后有效 } for (int i = 0; i 默认值 成员变量有默认值，但局部变量没有默认值，因此在使用局部变量之前，必须保证局部变量有具体的值 。 //例如:下列InitError类无法通过编译。 class InitError { int x = 10,y; //y的默认值是0 void f() { int m; //m没有默认值，但编译无错误 x = y+m; //无法通过编译，因为在使用m之前未指定m的值 } } 数据类型 实例成员 静态成员 整型(byte\\ short\\ int\\ long) 0 0 浮点型(float\\ double) 0 0 字符型(char) 空字符\\u0000 空字符\\u0000 布尔型( boolean) false false 引用型(类\\ 数组\\ 接口) null null public class DefaultValue { // 实例成员变量 private boolean bool; private byte b; private short s; private char c; private int i; private long l; private float f; private double d; private String str; private String[] strArray; // 静态成员变量 private static boolean boolStatic; private static byte bStatic; private static short sStatic; private static char cStatic; private static int iStatic; private static long lStatic; private static float fStatic; private static double dStatic; private static String strStatic; private static String[] strArrayStatic; public void printInstanceField() { System.out.println(\"实例成员变量默认值：\"); System.out.println(\"boolean:\" + bool); System.out.println(\"byte:\" + b); System.out.println(\"short:\" + s); System.out.println(\"char:\" + c); System.out.println(\"int:\" + i); System.out.println(\"long:\" + l); System.out.println(\"float:\" + f); System.out.println(\"double:\" + d); System.out.println(\"String:\" + str); System.out.println(\"String[]:\" + strArray); } public static void printStaticField() { System.out.println(\"静态成员变量默认值：\"); System.out.println(\"boolean:\" + boolStatic); System.out.println(\"byte:\" + bStatic); System.out.println(\"short:\" + sStatic); System.out.println(\"char:\" + cStatic); System.out.println(\"int:\" + iStatic); System.out.println(\"long:\" + lStatic); System.out.println(\"float:\" + fStatic); System.out.println(\"double:\" + dStatic); System.out.println(\"String:\" + strStatic); System.out.println(\"String[]:\" + strArrayStatic); } public static void main(String[] args) { DefaultValue dv = new DefaultValue(); dv.printInstanceField(); dv.printStaticField(); } } /* 实例成员变量默认值： boolean:false byte:0 short:0 char: int:0 long:0 float:0.0 double:0.0 String:null String[]:null 静态成员变量默认值： boolean:false byte:0 short:0 char: int:0 long:0 float:0.0 double:0.0 String:null String[]:null */ public class CharDefaultValue { static char c; public static void main(String[] args) { System.out.println((int) c); System.out.println(c == '\\u0000'); } } /* 0 true */ 可以把数组的元素看作是数组的成员变量（实际上不是），当数组分配空间时，数组的元素（行为类似于成员变量）就可以获得默认的初始值。不过，对于局部变量数组本身（即value），如果没有初始化，同样没有默认值。 public static void main(String[] args) { int[] value = new int[10]; System.out.println(value[0]); } //0 对象的组合与复用 一个类可以把对象作为自己的成员变量，如果用这样的类创建对象，那么该对象中就会有其它对象，也就是说该对象将其他对象作为自己的组成部分，或者说该对象是由几个对象组合而成。 如果一个对象a组合了对象b，那么对象a就可以委托对象b调用其方法，即对象a以组合的方式复用对象b的方法。通过组合对象来复用方法有以下特点。 （1）通过组合对象来复用方法也称“黑盒”复用，因为当前对象只能委托所包含的对象调用其方法，这样一来，当前对象对所包含的对象的方法的细节（算法的细节）是一无所知的。 （2）当前对象随时可以更换所包含的对象，即对象与所包含的对象属于弱耦合关系。 在学习对象的组合时，一定要记住：一个类声明的两个对象如果具有相同的引用，二者就具有完全相同的变量 如果一个类A把对象b作为自己的成员变量，用这个类A创建对象时，是不为这个b分配空间，只有一个b的null引用，需要用b对应的类Bnew一个对象b2，然后把b2引用给A，此时b和b2具有相同引用，指向相同的新建对象，这时候即时再用Bnew一个b2也不会对A的b造成影响。 class b{ getFunb{ } } //------------------- class A{ B b; //B是类，b是b声明的对象，类A把对象b作为自己的成员变量 setFuna(B temp){ b = temp; } getFuna(){ return getFunb()*2; //getFuna()函数调用getFunb函数 } } //-------------------- A a; //类A声明了对象a,此时a的只是一个引用，其他的什么也没有 //-------------------- a = new A(); //声明的对象a分配变量,此时a成员变量已经有了默认值，a的b是引用型变量，默认值是null //-------------------- B b1 = new B(); //B声明了一个对象b1，并为其分配变量，此时b1是一个引用，并且指向一个空间 /*（对象的本质就是变量，类数据类型和int一样，对象引用型变量，和int test 的test一样，只不过是个引用型变量，对比为数组，int test1[],test1和上面的b1一样，指向一个空间，自身是个引用变量，类似指针）*/ //-------------------- a.setFuna(b1); //a调用a的函数，将b1的引用传给a的b，此时b1和a的b拥有相同引用，指向相同的空间，且a的b可以委托调用B的方法 //-------------------- B b1 = new B(); //此时对A的a没有任何影响，只是b1重新指向别的空间了 //------------------- a.getFuna(); //a调用a的getFuna()函数，其中getFuna()函数调用getFunb函数 关联关系和依赖关系 关联关系 A中的成员变量是用B类声明的对象，那么A和B的关系是关联关系，称A类的对象关联于（或组合了）B类的对象 如下图Circular类的对象关联于（或组合了）Circle类的对象 依赖关系 参考： https://blog.csdn.net/xsj_blog/article/details/80018476 "},"page/1146.html":{"url":"page/1146.html","title":"方法定义","keywords":"","body":"方法定义 class 类名{ //类体内容： //变量声明: 成员变量=实例变量=实例=实例成员 static 成员变量=类变量=静态变量 //方法的定义: 实例方法=[修饰符] 类型 方法名称1(参数){ 构造函数=方法名称1() 局部变量 } 类方法=static 实例方法=static 类型 方法名称2(参数){ 构造函数=方法名称2() 局部变量 } } 方法的定义 包括两部分,方法声明和方法体. 一般格式为： 方法声明部分 { 方法体的内容 } 方法声明部分（方法头） 方法头由方法的类型、名称和名称之后的一对小括号以及其中的参数列表所构成。 int speak(){ //无参数的方法头 return 23; } int add(int x,int y,int z) //有参数的方法头 { return x+y+z; } 注意：方法返回的数据类型可以是Java中的任何数据类型之一，当一个方法不需要返回数据时，返回类型必须是void。 方法 方法声明之后的一对大括号“{” ，“}”以及之间的内容称为方法的方法体. 方法体的内容包括局部变量的声明和Java语句。 int getSum(int n) { //参数变量n是局部变量 int sum=0; // 声明局部变量sum for(int i=1;i 和类的成员变量不同的是，局部变量只在方法内有效，而且与其声明的位置有关。 方法的参数在整个方法内有效，方法内的局部变量从声明它的位置之后开始有效。如果局部变量的声明是在一个复合语句中，那么该局部变量的有效范围是该复合语句中且在声明位置之后开始有效。如果局部变量的声明是在一个循环语句中，那么该局部变量的有效范围是该循环语句。 public class test { int a = 10, b = 0; //成员变量，在整个类中有效 public static void main(String[] args) { //m = 9; //非法,因为m声明位置在后面,声明位置之后才有效 int m = 10, sum = 0; //局部变量，在函数中且在声明位置之后有效 if (m > 9) { // z = 2 * m + z; //非法,因为z声明位置在后面,声明位置之后才有效 int z = 10; //z仅仅在该复合语句后面有效 z = 2 * m + z; //合法，局部变量，在复合语句中且在声明位置之后有效 } for (int i = 0; i "},"page/1147.html":{"url":"page/1147.html","title":"特殊方法","keywords":"","body":"特殊方法 "},"page/1148.html":{"url":"page/1148.html","title":"构造方法","keywords":"","body":"构造方法 构造方法是一种特殊方法，它的名字必须与它所在的类的名字完全相同，而且没有类型。 class Test { int x = 10,y; int add() { System.out.println(x); } float add(int a,int b) { return a+b; } Test() //构造方法 { } } 构造方法： 构造方法是一种特殊方法，它的名字必须与它所在的类的名字完全相同，而且没有类型。 允许一个类中编写若干个构造方法，但必须保证他们的参数不同，即参数的个数不同，或者是参数的类型不同。 他的作用是在创建对象时使用，主要是用来初始化各个成员变量，以便给类所创建的对象一个合理的初始状态。 没有对成员方法初始化， 只有调用时才分配空间 如果类中没有编写构造方法，系统会默认该类只有一个构造方法，该默认的构造方法是无参数的，且方法体中没有语句。 如果类里定义了一个或多个构造方法，那么Java不提供默认的构造方法 。 class 梯形 { float 上底,下底,高; 梯形() { 上底=60; 下底=100; 高=20; } 梯形(float x,int y,float h) { 上底=x; 下底=y; 高=h; } } "},"page/1149.html":{"url":"page/1149.html","title":"重载方法","keywords":"","body":"重载方法 方法重载的意思是： 一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同，即或者是参数的个数不同，或者是参数的类型不同。方法的返回类型和参数的名字不参与比较 方法重载是一种多态的体现。 class Test { int x = 10,y; int add() { // System.out.println(x); } float add(int a,int b) // { return a+b; } Test() { } } "},"page/1165.html":{"url":"page/1165.html","title":"参数传值","keywords":"","body":"参数传值 方法中最重要的部分之一就是方法的参数，参数属于局部变量，当对象调用方法时，参数被分配内存空间，并要求调用者向参数传递值，即：方法被调用时，参数变量必须有具体的值 class Circle { double rad; void changeRad(double newRad) { rad=newRad; } } class Test { public static void main(String args[]) { Circle cir=new Circle(10); cir.changeRad(100); } } 传值机制 在Java中，方法的所有参数都是“传值”的，也就是说，方法中参数变量的值是调用者指定的值的拷贝。 1）对于基本数据类型的参数，向该参数“传值”，传递的是值的拷贝，例如，如果向方法的int型参数x传递一个int值，那么参数x得到的值是传递的值的拷贝。 2）对于参数是引用类型时，“传值”传递的是变量的引用而不是变量所引用的实体。Java的引用型数据包括对象、数组和接口。 对于基本数据类型的参数，传递的是值的拷贝。同时向该参数传递的值的级别不可以高于该参数的级别 。 class Circle { double rad; Circle(double r) { rad=r; } void changeRad(double newRad)// { rad=newRad; } } class Test { public static void main(String args[]) { Circle cir=new Circle(10); cir.changeRad(100);// } } 当参数是引用类型时，“传值”传递的是变量中存放的“引用”，而不是变量所引用的实体。 class Circle { Point p1; Circle(Point r) { p1=r; } } class Test { public static void main(String args[]) { Point p=new Point(1,2); Circle cir=new Circle(10); } } 可变参数 可变参数（The variable arguments）数是指在声明方法时不给出参数列表中从某项开始直至最后一项参数的名字和个数，但这些参数的类型必须相同。可变参数使用“…”表示若干个参数，这些参数的类型必须相同，并且最后一个参数必须是方法的参数列表中的最后一个参数。例如： public void f(int … x) 参数代表可以通过下标运算来表示参数列表中的具体参数，即x[0]，x[1]…x[m-1]分别表示x代表的第1个至第m个参数。 public int getSum(int... x) {//x可变参数的参数代表 int sum=0; for(int i=0;i "},"page/1172.html":{"url":"page/1172.html","title":"特殊类","keywords":"","body":"特殊类 "},"page/1173.html":{"url":"page/1173.html","title":"子类","keywords":"","body":"子类 继承是一种由已有的类创建新类的机制。利用继承，我们可以先创建一个共有属性的一般类，根据该一般类再创建具有特殊属性的新类，新类继承一般类的状态和行为，并根据需要增加它自己的新的状态和行为。由继承而得到的类称为子类，被继承的类称为父类（超类）。 Java不支持多重继承（子类只能有一个父类）。 声明子类 使用关键字extends来定义一个类的子类,格式如下： class 子类名 extends 父类名 { … } class Student extends People { … } //说明：把Student类定义为People类的子类、People类是Student类的父类 类的树形结构 Java的类按继承关系形成树形结构这个树形结构中，根节点是Object类（Object是java.lang包中的类），即Object是所有类的祖先类。 除了Object类，每个类都有且仅有一个父类，一个类可以有多个或零个子类。如果一个类（除了Object类）的声明中没有使用extends关键字，这个类被系统默认为是Object的子类，即类声明“class A”与“class A extends Object”是等同的。 子类的继承性 类可以有两种重要的成员：成员变量和方法。子类的成员中有一部分是子类自己声明定义的，另一部分是从它的父类继承的。 所谓子类继承父类的成员变量就是把继承来的变量作为自己的一个成员变量，就好象它们是在子类中直接声明一样，可以被子类中自己定义的任何实例方法操作。 所谓子类继承父类的方法就是把继承来的方法作为子类中的一个方法，就好象它们是在子类中直接定义了一样，可以被子类中自己定义的任何实例方法调用。 //例题：子类的继承 class Father { float weight,height; String head; void speak(String s) { System.out.println(s); } } class Son extends Father { String hand,foot; } Son s=new Son(); 作用域 当前类 同一包 不同包子孙类 不同包其他类 public 1 1 1 1 protected 1 1 1 0 friendly 1 1 0 0 private 1 0 0 0 子类和父类不在同一包中的继承性 如果子类和父类不在同一个包中，那么，子类继承了父类的protected、public成员变量做为子类的成员变量，并且继承了父类的protected、public方法为子类的方法，继承的成员或方法的访问权限保持不变。 public class People { int age,leg = 2,hand = 2; public void showPeopleMess() { System.out.printf(\"%d岁，%d只脚,%d只手\\t\",age,leg,hand); } } public class Student extends People { int number; void tellMessage() { showPeopleMess(); } } 子类与对象 子类继承了父类的很多东西，那么子类在创建对象的时候，他又是怎么生成自己的对象的呢。子类生产的对象会有哪些东西呢。 子类继承之后，未继承的也是有的，占空间的，只不过没办法用 子类对象的生成 子类创建对象时，子类的构造方法总是先调用父类的某个构造方法，完成父类部分的创建；然后再调用子类自己的构造方法，完成子类部分的创建。如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类的不带参数的构造方法 。 子类在创建一个子类对象时，不仅子类中声明的成员变量被分配了内存，而且父类的所有的成员变量也都分配了内存空间（子类没继承的也分配空间），但子类只能操作继承的那部分成员变量 。 子类可以通过继承的方法来操作子类未继承的变量和方法 . 调用子类构造方法时，先父类的构造方法，再调用子类构造方法 1）创建子类对象时，子类总是按层次结构从上到下的顺序调用所有超类的构造函数。如果继承和组合联用，要先构造基类的构造函数，然后调用组合对象的构造函数（组合按照声明的顺序调用）。 C继承B，B继承A，C生成对象，最远的A先构造 2）如果父类没有不带参数的构造方法，则在子类的构造方法中必须明确的告诉调用父类的某个带参数的构造方法，通过super关键字，这条语句还必须出现在构造方法的第一句。 "},"page/1174.html":{"url":"page/1174.html","title":"成员变量的隐藏和方法重写","keywords":"","body":"成员变量的隐藏和方法重写 成员变量的隐藏 对于子类可以从父类继承的成员变量，只要子类中声明的成员变量和父类中的成员变量同名时，子类就隐藏了继承的成员变量。 在子类中要操作这个与父类同名的成员变量时，子类操作的是子类重新声明的这个成员变量。而不是被隐藏掉的。 方法重写（Override） 同样，子类通过重写可以隐藏已继承的实例方法。 1.重写的语法规则 如果子类继承了父类的实例方法，那么子类就有权利重写这个方法。 方法重写是指：子类中定义一个方法，这个方法的类型和父类的方法的类型一致或是父类方法的类型的子类型，且这个方法的名字、参数个数、参数的类型和父类的方法完全相同. 除了方法参数名不一样（jdk1.5+ 重写方法是父类方法的子类型也可，如父类返回类型为Object，子类重写方法返回类型为Integer)，其他都一样 2.重写的目的 子类通过方法的重写可以隐藏继承的方法，子类通过方法的重写可以把父类的状态和行为改变为自身的状态和行为。 3.重写后方法的调用 子类创建的一个对象，如果子类重写了父类的方法，则运行时系统调用的是子类重写的方法; 子类创建的一个对象，如果子类未重写父类的方法，则运行时系统调用的是子类继承的方法; 4.重写的注意事项 重写父类的方法时，不允许降低方法的访问权限，但可以提高访问权限（访问限制修饰符按访问权限从高到低的排列顺序是：public、protected、友好的、private。） "},"page/1175.html":{"url":"page/1175.html","title":"对象的上转型对象","keywords":"","body":"对象的上转型对象 假设，A类是B类的父类，当用子类创建一个对象，并把这个对象的引用放到父类的对象中时，称对象a是对象b的上转型对象。 A a; a=new B(); 或 A a; B b=new B(); a=b; 上转型对象的使用 1.上转型对象不能操作子类新增的成员变量；不能调用子类新增的方法。 2.上转型对象可以访问子类继承或隐藏的成员变量，也可以调用子类继承的方法或子类重写的实例方法。 3.如果子类重写了父类的某个实例方法后，当用上转型对象调用这个实例方法时一定是调用了子类重写的实例方法。 "},"page/1176.html":{"url":"page/1176.html","title":"继承与多态","keywords":"","body":"继承与多态 多态性就是指父类的某个方法被其子类重写时，可以各自产生自己的功能行为。 "},"page/1177.html":{"url":"page/1177.html","title":"抽象类和抽象方法","keywords":"","body":"abstract类和abstract()方法 用关键字abstract修饰的类称为abstract类（抽象类）。 例如： abstract class A { … … } 用关键字abstract修饰的方法称为abstract方法(抽象方法) 例如： abstract int min(int x,int y); abstract类有如下特点 和普通的类相比，abstract类里可以有abstract方法。也可以没有。对于abstract方法，只允许声明，不允许实现，而且不允许使用final修饰abstract方法。 抽象类可以有正常方法和抽象方法，正常类只能有正常方法 对于abstract类，不能使用new运算符创建该类的对象，只能产生其子类，由子类创建对象。 如果一个类是abstract类的子类，它必须具体实现父类的所有的abstract方法。 理解抽象类 （1）抽象类可以抽象出重要的行为标准，该行为标准用抽象方法来表示。即抽象类封装了子类必需要有的行为标准。 （2）抽象类声明的对象可以成为其子类的对象的上转型对象，调用子类重写的方法，即体现子类根据抽象类里的行为标准给出的具体行为。 人们已经习惯给别人介绍数量标准，例如，在介绍人时候，可以说，人的身高可以是float型的，头发的个数可以是int型的，但是学习了类以后，也要习惯介绍行为标准。所谓行为的标准仅仅是方法的名字，方法的类型而已，就像介绍人的头发数量标准是int型，但不要说出有多少根头发。例如，人具有run行为，或speak行为，但仅仅说出行为标准，不要说出speak行为的具体体现，即不要说speak行为是用英语说话或中文说话 开发者可以把主要精力放在一个应用中需要那些行为标准（不用关心行为的细节），不仅节省时间，而且非常有利于设计出易维护、易扩展的程序（见后面的5.10节）。抽象类中的抽象方法，可以由子类去实现，即行为标准的实现由子类完成。 "},"page/1150.html":{"url":"page/1150.html","title":"类使用","keywords":"","body":"类使用 "},"page/1151.html":{"url":"page/1151.html","title":"创建对象","keywords":"","body":"创建对象 类是面向对象语言中最重要的一种数据类型，那么就可以用它来声明变量。在面向对象语言中，用类声明的变量被称作对象。 和基本数据类型不同，在用类声明对象后，还必须要创建对象，即为声明的对象分配变量(确定对象所具有的属性)，当使用一个类创建一个对象时，也称给出了这个类的一个实例。通俗的讲，类是创建对象的“模板”，没有类就没有对象。构造方法和对象的创建密切相关 。 创建一个对象包括对象的声明和为对象分配变量两个步骤。 "},"page/1152.html":{"url":"page/1152.html","title":"对象的声明","keywords":"","body":"对象的声明 对象的声明 一般格式为： 类的名字 对象名字; //如： XiyoujiRenwu zhubajie; "},"page/1153.html":{"url":"page/1153.html","title":"为声明的对象分配变量","keywords":"","body":"为声明的对象分配变量 为声明的对象分配变量 使用new运算符和类的构造方法为声明的对象分配变量，并返回一个引用值给对象名称。即创建对象。如果类中没有构造方法，系统会调用默认的构造方法，默认的构造方法是无参数的，且方法体中没有语句。 对象名字 = new 类的构造方法(对象的构造参数)； zhubajie = new XiyoujiRenwu(); class XiyoujiRenwu { float height,weight; String head, ear; void speak(String s) { System.out.println(s); } } public class Example{ public static void main(String args[]) { XiyoujiRenwu zhubajie; //声明对象 zhubajie = new XiyoujiRenwu(); //为声明的对象分配变量 } } 当用类创建一个对象时，类中的成员变量被分配内存空间，这些内存空间称作该对象的实体或对象的变量，而对象中存放着引用值。一个类创建的两个对象，如果具有相同的引用，那么就具有完全相同的实体。 class Point{ double x,y; Point(double x,double y){ this.x=x; this.y=y; } } //使用Point类创建了两个对象p1，p2： Point p1 = new Point (5,15); Point p2 = new Point(8,18); 假如在程序中使用了如下的赋值语句：p1 = p2; 即把p2中的引用赋给了p1，因此p1和p2本质上是一样的.一个类创建的两个对象，如果具有相同的引用，那么就具有完全相同的实体(变量)。 对象的内存模型 通过对象的声明和分配内存后，每个对象都对应两个值：引用值和实体值。 1）左声明对象时的内存模型 2）右对象分配变量后的内存模型 分析：当系统见到： zhubajie=new XiyoujiRenwu(); 系统会使用new运算符为变量height，weight，head，ear等分配内存，将返回一个引用值给对象变量zhubajie。同时调用构造函数为各个变量初始化。 结论：每个对象都有属于自己的空间；都有属于自己的成员；但有时也有大家共有的空间和成员。 3)创建多个不同的对象 一个类通过使用new运算符可以创建多个不同的对象。例如创建两个对象：zhubajie、sunwukong ​ 如:zhubajie = new XiyoujiRenwu(); sunwukong = new XiyoujiRenwu "},"page/1154.html":{"url":"page/1154.html","title":"使用对象","keywords":"","body":"使用对象 使用对象 对象创建成功后，可以操作类中的变量和方法： 1．对象操作自己的变量（体现对象的属性） ​ 通过使用运算符“.” 对象操作自己的变量（对象的属性）。 2．对象调用类中的方法（体现对象的行为） ​ 对象创建之后，可以使用点运算符“.”调用创建它的类中的方法，从而产生一定的行为（功能）。 当对象调用变量时，是指调用分配给该对象自己的变量。 类中的方法可以操作成员变量；当对象调用方法时，方法中出现的成员变量就是指分配给该对象的那个变量。 访问权限 当用一个类创建了一个对象之后，该对象可以通过“.”运算符操作自己的变量、使用类中的方法，但对象操作自己的变量和使用类中的方法是有一定限制的。 所谓访问权限是指对象是否可以通过“.”运算符操作自己的变量或通过“.”运算符使用类中的方法。 访问限制修饰符有private、protected和public，都是Java的关键字，用来修饰成员变量或方法。 "},"page/1076.html":{"url":"page/1076.html","title":"数组","keywords":"","body":"数组 数组是相同类型的数据按顺序组成的一种复合数据类型。通过数组名加数组下标，来使用数组中的数据。下标从0开始排序。 声明数组 声明一维数组有下列两种格式： 数组的元素类型 数组名[]; 数组的元素类型 [] 数组名; 例如： float boy[]; char [] cat; 声明二维数组有下列两种格式： 数组的元素类型 数组名; 数组的元素类型 数组名; 例如： float a; Char b; 为数组分配元素空间 为数组分配元素的格式如下： 数组名 = new 数组元素的类型[数组元素的个数]; 例如： boy = new float[4]; 说明： 数组属于引用型变量，数组变量中存放着数组的首元素的地址，通过数组变量的名字加索引使用数组的元素 比如： boy[0] = 12; boy[1] = 23.908F; boy[2] = 100; boy[3] = 10.23f; 数组的内存模型 注意： 数组的声明和分配空间可以在声明时同时完成 float boy []=new float[4]; 数组的初始化 创建数组后，系统会给数组的每个元素一个默认的值 例如，float型是0.0。 如果需要赋值，就要为每个元素赋值 例如： float boy []=new float[4]; boy[0] = 12; boy[1] = 23.908F; boy[2] = 100; boy[3] = 10.23f; 在声明数组的同时也可以给数组的元素一个初始值,如: float boy[] = { 21.3f,23.89f,2.0f,23f,778.98f}; 数组元素的使用 一维数组 通过索引（下标运算）符访问自己的元素。 如boy[0]，boy[1]等. 注意 索引从0开始，因此，数组若有4个元素，那么索引到3为止，因此在使用数组时必须谨慎，防止索引越界。 如果程序使用了如下语句： boy[4] = 384.98f; 程序可以编译通过，但运行时将发生ArrayIndexOutOfBoundsException异常 数组的引用 数组属于引用型变量，两个相同类型的数组如果具有相同的引用，它们就有完全相同的元素。 对于 int a[] = {1,2,3},b[ ] = {4,5}; 数组变量a和b分别存放着引用de6ced和c17164，内存模型如下图所示 数组a、b的内存模型 进行赋值a = b; 那么，a中存放的引用和b的相同，这时系统将释放最初分配给数组a的元素，使得a的元素和b的元素相同，a、b的内存模型变成如下图所示。 a=b后数组a、b的内存模型 length的使用 length字段的使用 对于一维数组，“数组名.length”的值就是数组中元素的个数； 对于二维数组“数组名.length”的值是它含有的一维数组的个数 例如： float boy []=new float[4]; boy.length的值为4. int [][] a = new int[3][8]; a.length的值是3. a[0].length的值是8 a[1].length的值是8 a[2].length的值是8 对象数组 如果程序需要某个类的若干个对象，比如Student类的10个对象，显然如下声明10个Student对象是不可取的： Student stu1,stu2, stu3,stu4,stu5,stu6,stu7,stu8, stu9,stu10; 正确的做法是使用对象数组，即数组的元素是对象，例如： Student [] stu; stu = new Student[10]; 需要注意的是，上述代码仅仅定义了数组stu有10个元素，并且每个元素都是一个Student类型的对象，但这些对象目前都是空对象，因此在使用数组stu中的对象之前，应当创建数组所包含的对象。 例如： stu[0] = new Student(); "},"page/1077.html":{"url":"page/1077.html","title":"接口","keywords":"","body":"接口 为了克服Java单继承的缺点，Java使用了接口，一个类可以实现多个接口。 使用关键字interface来定义一个接口。接口的定义和类的定义很相似，分为接口的声明和接口体。 1.接口声明 接口通过使用关键字interface来声明 格式：interface 接口的名字 2.接口体 接口体中包含常量定义和方法定义两部分。接口体中只进行方法的声明，不许提供方法的实现，所以，方法的定义没有方法体，且用分号“；”结尾。 interface Printable { final int MAX=100; void add(); float sum(float x ,float y); } 接口的变量和方法的构成规则 接口中的变量自动都是public、static，final， 接口中的方法默认为public abstract；接口也产生class文件。 接口中的方法不能被static和final修饰，因为要重写所有接口中的方法。(一但声明就是接口的方法，下面没法用了) 接口中没有构造函数，方法可以抛出异常。 实现接口 一个类通过使用关键字implements声明自己实现一个或多个接口。 如：class A implements Printable,Addable 如果一个类实现了某个接口，那么这个类必须重写该接口的所有方法。 接口可以通过继承产生新的接口。 Java提供的接口都在相应的包中，通过import语句不仅可以引入包中的类，也可以引入包中的接口， 例如:import java.io.*; 实现接口的方法必须是public，否则默认友元类了，但是权限只能提高 接口回调 接口回调是指：可以把实现某一接口的类创建的对象的引用赋给该接口声明的接口变量中，那么该接口变量就可以调用被类重写的接口方法。实际上，当接口变量调用被类重写的接口方法时，就是通知相应的对象调用这个方法。 分析： Com com;//声明接口对象 ImpleCom obj= new ImpleCom();//实现接口子类对象 com = obj; //接口回调 (在类里叫向上转型) 理解接口 理解的关键点是：（1）接口可以抽象出重要的行为标准，该行为标准用抽象方法来表示。（2）可以把实现接口的类的对象的引用赋值给接口变量，该接口变量可以调用被该类实现的接口方法，即体现该类根据接口里的行为标准给出的具体行为。 接口的思想在于它可以要求某些类有相同名称的方法，但方法的具体内容（方法体的内容）可以不同，即要求这些类实现接口，以保证这些类一定有接口中所声明的方法（即所谓的方法绑定）。接口在要求一些类有相同名称的方法的同时，并不强迫这些类具有相同的父类。 接口与多态 可以通过在接口中声明若干个abstract方法，表明这些方法的重要性，方法体的内容细节由实现接口的类去完成。使用接口进行程序设计的核心思想是使用接口回调，即接口变量存放实现该接口的类的对象的引用，从而接口变量就可以回调类实现的接口方法。 接口参数 如果一个方法的参数是接口类型，我们就可以将任何实现该接口的类的实例的引用传递给该接口参数，那么接口参数就可以回调类实现的接口方法。 abstract类与接口的比较 接口和abstract类的比较如下：1．abstract类和接口都可以有abstract方法。2．接口中只可以有常量,不能有变量；而abstract类中即可以有常量也可以有变量。3．abstract类中也可以有非abstract方法,接口不可以。 面向接口编程 面向接口去设计程序，可以通过在接口中声明若干个abstract方法，表明这些方法的重要性，方法体的内容细节由实现接口的类去完成。 使用接口进行程序设计的核心思想是使用接口回调，即接口变量存放实现该接口的类的对象的引用，从而接口变量就可以回调类实现的接口方法。 "},"page/1078.html":{"url":"page/1078.html","title":"类型转换","keywords":"","body":"类型转换 基本类型 排序 Java中数据的基本类型(不包括逻辑类型)按精度从“低”到“高”排列： byte short char int long float double 数值型 规则： 当把级别低的变量的值赋给级别高的变量时，系统自动完成数据类型的转换。 例如：float x=100; 当把级别高的变量的值赋给级别低的变量时，必须使用显示类型转换运算。 显示转换的格式：（类型名）要转换的值; 例如：int x=(int)34.89; 注意：当把一个int型常量赋值给一个byte和short型变量时，不可以超出这些变量的取值范围，否则必须进行类型转换运算； 例如： byte b=128;(error) byte b=(byte)128(ok) 字符串型数据与整型数据相互转换 字符串转换成数值型数据 数字字符串型数据转换成byte、short、int、float、double、long等数据类型，可以分别使用下表所提供的Byte、Short、Integer、Float、Double、Long类的parseXXX方法 字符串转换成数值型数据的方法 转 换 的 方 法 功 能 说 明 Byte.parseByte() 将字符串转换为字节型数据 Short.parseShort() 将字符串转换为短整型数据 Integer.parseInt() 将字符串转换为整型数据 Long.parseLong() 将字符串转换为长整型数据 Float.parseFloat() 将字符串转换为浮点型数据 Double.parseDouble() 将字符串转换为双精度型数据 例如： String MyNumber=\"1234.567\"； //定义字符串型变量MyNumber float MyFloat=Float.parseFloat(MyNumber); "},"page/1079.html":{"url":"page/1079.html","title":"常量与变量","keywords":"","body":"常量与变量 "},"page/1080.html":{"url":"page/1080.html","title":"常量","keywords":"","body":"常量 "},"page/1081.html":{"url":"page/1081.html","title":"变量","keywords":"","body":"变量 "},"page/1129.html":{"url":"page/1129.html","title":"修饰符","keywords":"","body":"修饰符 "},"page/1130.html":{"url":"page/1130.html","title":"访问控制修饰符","keywords":"","body":"访问控制修饰符 public类与友好类 类声明时，如果在关键字class前面加上public关键字，就称这样的类是一个public 类 。 可以在任何另外一个类中,使用public类创建对象。 如果一个类不加public修饰，这样的类被称作友好类。 在另外一个类中使用友好类创建对象时，要保证它们是在同一包中。 "},"page/1155.html":{"url":"page/1155.html","title":"default","keywords":"","body":"default 友好变量和友好方法 当在另外一个类中用类Tom 创建了一个对象后，如果这个类与Tom类在同一个包中，那么该对象能访问自己的友好变量和友好方法。 在任何一个与Tom同一包中的类中，也可以通过Tom类的类名访问Tom类的类友好成员变量和类友好方法。 "},"page/1156.html":{"url":"page/1156.html","title":"private","keywords":"","body":"private 私有变量和私有方法 用关键字private修饰的成员变量和方法称为私有变量和私有方法。 对于私有成员变量或方法，只有在本类中创建该类的对象时，这个对象才能访问自己的私有成员变量和类中的私有方法。 某个类在另外一个类中创建对象后，如果不希该对象直接访问自己的变量，即通过“.”运算符来操作自己的成员变量，就应当将该成员变量访问权限设置为private。 面向对象编程提倡对象应当调用方法来改变自己的属性，类应当提供操作数据的方法，这些方法可以经过精心的设计，使得对数据的操作更加合理。 class tom{ private float weight; private float f(float a, float b){ } } class jerry{ void g(){ tom tt = new tome(); tt weight = 23; //error tt f(3,4); //error } } "},"page/1157.html":{"url":"page/1157.html","title":"public","keywords":"","body":"public 共有变量和共有方法 用public修饰的成员变量和方法被称为共有变量和共有方法 。 我们在任何一个类中用类A创建了一个对象后，该对象能访问自己的public变量和类中的public方法（也可以通过类名来操作成员变量、方法） 。 "},"page/1158.html":{"url":"page/1158.html","title":"protected","keywords":"","body":"protected 用protected修饰的成员变量和方法被称为受保护的成员变量和受保护的方法 。 "},"page/1131.html":{"url":"page/1131.html","title":"非访问控制修饰符","keywords":"","body":"非访问控制修饰符 "},"page/1159.html":{"url":"page/1159.html","title":"static","keywords":"","body":"static 方法 类中的方法也可分为实例方法和类方法. 方法声明时，方法类型前面不加关键字static的是实例方法、加关键字static的是类方法。 class Test { int x = 10,y; void f() { System.out.println(x); } static int add(int a,int b) //类方法 { return a+b; } Test( ) //构造函数 { } } 变量 1 实例变量和类变量的声明 ​ 在声明成员变量时，用关键字static给予修饰的称作类变量，否则称作实例变量（类变量也称为static变量，静态变量）。 2 实例变量和类变量的区别 ​ 不同对象的实例变量互不相同,所有对象共享类变量,通过类名直接访问类变量 3 实例方法和类方法的定义 ​ 类中的方法也可分为实例方法和类方法。方法声明时，方法类型前面不加关键字static修饰的是实例方法、加static关键字修饰的是类方法(静态方法)。 4 实例方法和类方法的区别 1）对象调用实例方法 ​ 当对象调用实例方法时，该方法中出现的实例变量就是分配给该对象的实例变量；该方法中出现的类变量也是分配给该对象的变量，只不过这个变量和所有的其他对象共享而已。 ​ 2）类名调用类方法 ​ 从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。和实例方法不同的是，类方法不可以操作实例变量，这是因为在类创建对象之前，实例成员变量还没有分配内存。 "},"page/1160.html":{"url":"page/1160.html","title":"final","keywords":"","body":"final final关键字可以修饰类、成员变量和方法中的局部变量。 可以使用final将类声明为final类。final类不能被继承，即不能有子类。 //如 final class A { … … } 如果用final修饰父类中的一个方法，那么这个方法不允许子类重写。 如果成员变量或局部变量被修饰为final的，就是常量（类似于C的符号常量）。 "},"page/1161.html":{"url":"page/1161.html","title":"abstract","keywords":"","body":"abstract "},"page/1162.html":{"url":"page/1162.html","title":"synchronized","keywords":"","body":"synchronized "},"page/1163.html":{"url":"page/1163.html","title":"volatile","keywords":"","body":"volatile "},"page/1167.html":{"url":"page/1167.html","title":"辅助关键字","keywords":"","body":"辅助关键字 "},"page/1166.html":{"url":"page/1166.html","title":"this","keywords":"","body":"this this关键字 this是Java的一个关键字，表示某个对象。this可以出现在实例方法和构造方法中，但不可以出现在类方法中。 this关键字出现在类的构造方法中时，代表使用该构造方法所创建的对象. 当this关键字出现实例方法中时，this就代表正在调用该方法的当前对象。 实例方法必须只能通过对象来调用，不能用类名来调用。 实例方法可以操作类的成员变量，当实例成员变量在实例方法中出现时，默认的格式是： this.成员变量; 当static成员变量在实例方法中出现时，默认的格式是： 类名.成员变量; "},"page/1168.html":{"url":"page/1168.html","title":"super","keywords":"","body":"super关键字 1 用super操作被隐藏的成员变量和方法 子类可以隐藏从父类继承的成员变量和方法，如果在子类中想使用被子类隐藏的成员变量或方法就可以使用关键字super。比如super.x、super.play()就是访问和调用被子类隐藏的成员变量x和方法play(). 2 使用super调用父类的构造方法 子类不继承父类的构造方法，因此，子类如果想使用父类的构造方法，必须在子类的构造方法中使用，并且必须使用关键字super来表示，而且super必须是子类构造方法中的头一条语句。 "},"page/1039.html":{"url":"page/1039.html","title":"运算符与表达式","keywords":"","body":"运算符 Java提供了丰富的运算符，如算术运算符、关系运算符、逻辑运算符、位运算符等。 "},"page/1050.html":{"url":"page/1050.html","title":"按照属性分类","keywords":"","body":"按照属性分类 Java的表达式就是用运算符连接起来的符合Java规则的式子。 运算符的优先级决定了表达式中运算执行的先后顺序。 在编写程序时尽量使用括号（）运算符号来实现想要的运算次序，以免产生难以阅读或含糊不清的计算顺序。 运算符的结合性决定了具有相同级别运算符的先后顺序 。 "},"page/1051.html":{"url":"page/1051.html","title":"基本","keywords":"","body":"基本 "},"page/1052.html":{"url":"page/1052.html","title":"赋值","keywords":"","body":"赋值 赋值运算符：= 赋值运算符是二目运算符，左面的操作元必须是变量，不能是常量或表达式。 赋值运算符的优先级较低，是14级，结合方向右到左。 赋值表达式的值就是“=”左面变量的值。 注意:不要将赋值运算符“=”与等号逻辑运算符“==”混淆。 例如：x=20; b=true; "},"page/1053.html":{"url":"page/1053.html","title":"括号","keywords":"","body":"括号 "},"page/1054.html":{"url":"page/1054.html","title":"逗号","keywords":"","body":"逗号 "},"page/1055.html":{"url":"page/1055.html","title":"计算","keywords":"","body":"计算 "},"page/1056.html":{"url":"page/1056.html","title":"算术","keywords":"","body":"算术运算符与算术表达式 加减运算符: +，- 加减运算符是二目运算符； 加减运算符的结合方向是从左到右； 加减运算符的操作元是整型或浮点型数据， 加减运算符的优先级是4级。 乘、除和求余运算符： * / % 以上运算符是二目运算符， 结合方向是从左到右， 乘、除和求余运算符的操作元是整型或浮点型数据。 运算符的优先级是3级。 算术表达式 用算术符号和括号连接起来的符合java语法规则的式子，称为算术表达式。 如：x+2*y-30+3*(y+5) 自增、自减运算符：++，-- 单目运算符，可以放在操作元之前，也可以放在操作元之后。操作元必须是一个整型或浮点型变量。 作用是使变量的值增1或减1，如： ++x（--x）表示在使用x之前，先使x的值增（减）1。 x++（x--）表示在使用x之后，使x的值增（减）1。 例如： int f=2; int m=2; int x=(f*m++)+m; //x=7; int y=(f*++m)+m; //y=9; 算术混合运算的精度 java中数据类型的精度从“低”到“高”排列的顺序是： byte short char int long float double Java在计算算术表达式的值时,使用下列计算精度规则： 如果表达式中有双精度浮点数（double型数据），则按双精度进行运算. 如果表达式中最高精度是单精度浮点数（float型数据），则按单精度进行运算. 如果表达式中最高精度是long型整数，则按long精度进行运算. 如果表达式中最高精度低于int型整数,则按int精度进行运算. char型数据和整型数据运算结果的精度是int。 例如：5/2的结果是2，要想得到2.5,必须写成5.0/2或5.0f/2。 例如：byte x=7; 则执行表达式 ‘B’+x; 的结果是int型。 "},"page/1057.html":{"url":"page/1057.html","title":"位操作","keywords":"","body":"位操作 位运算符 是指对两个整型数据按照对应的位进行运算，结果为新的整型数据。 “按位与”运算 “&”是双目运算符。运算法则是：如果a，b两个数据对应位都是1，则c的该位是1，否则是0。 “按位或”运算 “|”是双目运算符。运算法则是：如果a，b两个数据对应位都是0，则c的该位是0，否则是1。 “按位非”运算 “~”是单目运算符。运算法则是：如果a对应位都是0，则c的该位是1，否则是1。 “按位异或”运算 “^”是双目运算符。运算法则是：如果a，b两个数据对应位相同，则c的该位是0，否则是1。 //中利用“异或”运算的性质，对几个字符进行加密并输出密文，然后再解密。 class Example3_1 { public static void main(String args[]) { char a1='十',a2='点',a3='进',a4='攻'; char secret='8'; a1=(char)(a1^secret); a2=(char)(a2^secret); a3=(char)(a3^secret); a4=(char)(a4^secret); System.out.println(\"密文:\"+a1+a2+a3+a4); a1=(char)(a1^secret); a2=(char)(a2^secret); a3=(char)(a3^secret); a4=(char)(a4^secret); System.out.println(\"原文:\"+a1+a2+a3+a4); } } "},"page/1058.html":{"url":"page/1058.html","title":"判断","keywords":"","body":"判断 "},"page/1059.html":{"url":"page/1059.html","title":"关系","keywords":"","body":"关系运算符与关系表达式 关系运算符: > , = , 特点： 关系运算符是二目运算符，用来比较两个值的关系 关系运算符的运算结果是boolean型，当运算符对应的关系成立时，运算结果是true，否则是false。 运算规则： 在关系运算符中，当操作数是基本数据类型时，比较的是数据内容； 在关系运算符中，当操作数是引用类型时，比较的是引用对象的引用值，判断是否是同一对象，而没有比较对象的内容。 如，4>8，(x+y)>80。 运算符 优先级 用法 含义 结合方向 > 6 op1 > op2 大于 左到右 6 op1 小于 左到右 >= 6 op1 >= op2 大于等于 左到右 6 op1 小于等于 左到右 == 7 op1 == op2 等于 左到右 != 7 op1 != op2 不等于 左到右 "},"page/1060.html":{"url":"page/1060.html","title":"逻辑","keywords":"","body":"逻辑运算符与逻辑表达式 逻辑运算符包括： &&、||、! 其中：&&、|| 为二目运算符,实现逻辑与、逻辑或；！为单目运算符，实现逻辑非。 规则： 逻辑运算符的操作元必须是boolean型数据，逻辑运算符可以用来连接关系表达式 op1 op2 op1 && op2 op1 \\ \\ op2 ! op1 true true true true false true false false true false false true false true true false false false false true 用逻辑运算符进行逻辑运算 注意： &&，||也称短路运算符 当前面的表达式op1的值为false时，&&运算符在运算时就不再去计算op2表达式的值；当op1为true时，||运算符就不再计算op2的值。（op1&&op2；op1||op2）。 class Test { public static void main(String args[]) { int x,y=10; if( ((x=0)==0) || ((y=20)==20) ) { System.out.println(\"现在y的值是:\"+y); } } } //现在y的值是:10 "},"page/1061.html":{"url":"page/1061.html","title":"条件","keywords":"","body":"条件 "},"page/1062.html":{"url":"page/1062.html","title":"父子","keywords":"","body":"instanceof 运算符 instanceof 运算符 是二目运算符，左面的操作元是一个对象；右面是一个类。当左面的对象是右面的类或子类创建的对象时，该运算符运算的结果是true ，否则是false。 class Test { public static void main (String argv[]) { String s=new String(“abc”); if(s instanceof String) System.out.println(“s is a string”); B b=new B(); if(b instanceof Object) System.out.println(\"b is definitedly an object\"); } } "},"page/1063.html":{"url":"page/1063.html","title":"构件","keywords":"","body":"构件 "},"page/1064.html":{"url":"page/1064.html","title":"字符串连接符","keywords":"","body":"字符串连接符 "},"page/1065.html":{"url":"page/1065.html","title":"按照参与个数分类","keywords":"","body":"按照参与个数分类 "},"page/1066.html":{"url":"page/1066.html","title":"单目","keywords":"","body":"单目 "},"page/1067.html":{"url":"page/1067.html","title":"双目","keywords":"","body":"双目 "},"page/1068.html":{"url":"page/1068.html","title":"三目","keywords":"","body":"三目 "},"page/1040.html":{"url":"page/1040.html","title":"优先级","keywords":"","body":"优先级 "},"page/1033.html":{"url":"page/1033.html","title":"语句","keywords":"","body":"语句 Java里的语句可分为以下六类 方法调用语句：如：System.out.println(\" Hello\"); 表达式语句：表示式尾加上分号。比如赋值语句：x=23; 复合语句：可以用{ }把一些语句括起来构成复合语句， 如：{ z=123+x; System.out.println(\"How are you\"); } 空语句：一个分号也是一条语句，称做空语句。 控制语句：控制语句分为条件分支语句、开关语句和循环语句。 package语句和 import语句：它们和类、对象有关。 "},"page/1137.html":{"url":"page/1137.html","title":"语句块","keywords":"","body":"语句块 "},"page/1032.html":{"url":"page/1032.html","title":"流程设计","keywords":"","body":"流程设计 "},"page/1034.html":{"url":"page/1034.html","title":"选择结构","keywords":"","body":"选择结构 if条件分支语句 条件分支语句按着语法格式可细分为三种形式： if语句 if-else语句 if-else if- ……- else if -else 语句 if语句 if语句是单条件分支语句，即根据一个条件来控制程序执行的流程 if 语句的语法格式： if（表达式）{ 若干语句 } 注意：表达式的值必须是boolean型的；不能用0代表false；用1代表true； //将变量a，b，c内存中的数值按大小顺序进行互换（从小到大排列）。 public class Example3_2 { public static void main(String args[]) { int a = 9,b = 5,c = 7,t=0; if(b if-else 语句 if-else 语句是双条件分支语句，即根据一个条件来控制程序执行的流程。 if-else 语句的语法格式： if（表达式） { 若干语句 } else { 若干语句 } if-else if-else 语句 if-elseif 语句是多条件分支语句，即根据多个条件来控制程序执行的流程。 if-else if-else语句的语法格式： if（表达式) { 若干语句 }else if（表达式) { 若干语句 } … … else { 若干语句 } switch开关语句 switch 语句是单条件多分支的开关语句 它的一般格式定义如下(其中break语句是可选的）： switch(表达式){ case 常量值1: 若干个语句 break; case 常量值2: 若干个语句 break; ... case 常量值n: 若干个语句 break; default: 若干语句 } 说明： 1)表达式的值必须是：byte，short，int，char不能是String或者long型的；（与int兼容类型） 2)没有break语句，就会匹配显示从匹配的常量值到最后。 3)default语句放的位置是任意的。 4)检查时case 常量必须与switch表达式可用的类型相同。 5)根据2)和4)，switch的结束只有两种情况，到语句末尾，碰到break. import java.util.Scanner; public class test { public static void main(String args[]) { int number = 0; Scanner reader = new Scanner(System.in); number = reader.nextInt(); switch (number) { case 1: System.out.println(\"1\"); break; case 2: System.out.println(\"2\"); break; default: System.out.println(\"666\"); //如果不是123，不会执行完本句就结束，而是一直到末尾或者碰到break case 3: System.out.println(\"3\"); break; } } } /* 输入 6 输出 666 3 */ "},"page/1035.html":{"url":"page/1035.html","title":"循环结构","keywords":"","body":"循环结构 循环语句 1.for循环语句 for语句的语法格式： for (表达式1; 表达式2; 表达式3) { 若干语句 } for语句的执行规则是： (1)计算“表达式1”，完成必要的初始化工作。 (2)判断“表达式2”的值，若“表达式2”的值为true，则进行(3),否则进行(4)。 (3)执行循环体，然后计算“表达式3”，以便改变循环条件，进行（2）。 (4)结束for语句的执行。 //1+22+333前9项 for(int i=0; i //求100以内素数 public class test { public static void main(String[] args) { int i, j, k; for (i = 2; i k) { //说明被除数j已经超过一半k了，里面都除不尽,此时的i是个奇数 System.out.print(i + \",\"); } } } } //2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97, /* 一个数如果恰好等于它的因子和，这个数就成为完数。 例如：6 = 1 + 2 + 3。再如 8 的因子和是7（即1 + 2 + 4)，8不是完数。 编程找出1000以内的所有完数。 */ public class test { public static void main(String[] args) { for (int i=1; i 2.while 循环 while语句的语法格式： while (表达式) { 若干语句 } while语句的执行规则是： (1)计算表达式的值,如果该值是true时，就进行(2),否则执行(3)。 (2)执行循环体，再进行(1)。 (3)结束while语句的执行。 //用while语句计算1+1/2!+1/3!+1/4! … 的前20项 int i = 1,n = 20; while(i /* 用户在键盘依次输入若干个数字，每输入一个数字都需要按回车键确认，最后在键盘输入一个非数字字符串结束整个输入操作过程。程序将计算出这些数的和以及平均值。在从键盘输入数据时，经常让reader对象先调用hasNextXXX()方法等待用户在键盘输入数据，然后再调用nextXXX()方法获取用户输入的数据。 */ while(reader.hasNextDouble()){ double x = reader.nextDouble(); m = m + 1; sum = sum + x; } import java.util.*; public class text{ public static void main(String arg[]){ Scanner reader =new Scanner(System.in); double sum=0; int m=0; while(reader.hasNextDouble()){ double x=reader.nextDouble(); m=m+1; sum=sum+x; } System.out.printf(\"%d个数的和为%f\\n\",m,sum); System.out.printf(\"%d个数的平均值为%f\\n\",m,sum/m); } } 3.do-while循环 do-while语句的语法格式： do { 若干语句 } while(表达式); do- while语句的执行规则是： (1)执行循环体，再进行(2)。 (2)计算表达式的值，如果该值是true时,就进行(1),否则执行(3)。 (3)结束while语句的执行。 4.break和continue语句 break和continue语句是用关键break或continue加上分号构成的语句。 在循环体中可以使用break语句和continue语句。 如果在某次循环中执行了break语句，那么本层整个循环语句就结束。如果在某次循环中执行了continue语句，那么本次循环就结束，即不再执行本次循环中循环体中continue语句后面的语句，而转入进行下一次循环。 //使用了continue和break语句,计算1+3+5…输出100内的素数. //循环变化快的在内循环里面，变化慢的在外循环里面 public class test { public static void main(String args[]) { int sum=0,i,j; for( i=1;ij/2) j/2) { // 5.for语句与数组 JDK1.5后,对for语句的功能给予扩充、增强，以便更好地遍历数组。语法格式如下： for(声明循环变量：数组的名字) { …… } 其中，声明的循环变量的类型必须和数组的类型相同。这种形式的for语句类似自然语言中的“for each”语句，为了便于理解上述for语句，可以将这种形式的for语句翻译成“对于循环变量依次取数组的每一个元素的值”。 //分别使用for语句的传统方式和改进方式遍历数组。 public class test { public static void main(String args[]) { int a[] = {1,2,3,4}; char b[] = {'a','b','c','d'}; for(int n=0;n "},"page/1135.html":{"url":"page/1135.html","title":"导入机制","keywords":"","body":"导入机制 "},"page/1044.html":{"url":"page/1044.html","title":"包","keywords":"","body":"包 包是Java语言中有效地管理类的一个机制。 包名的目的是有效的区分名字相同的类。不同Java源文件中两个类名字相同时，它们可以通过隶属不同的包来相互区分。 包语句 通过关键字package声明包语句。 package语句作为Java源文件的第一条语句， 为该源文件中声明的类指定包名。 package语句的一般格式为： package 包名; ​ 有包名的类的存储目录 程序如果使用了包语句，例如： package net.zlogs; 那么存储文件的目录结构中必须包含有如下的结构 …\\net\\zlogs 如：c:\\1000\\net\\zlogs 并且要将源文件编译得到的类的字节码文件保存在目录c:\\1000\\net\\zlogs中（源文件可以任意存放）。 运行有包名的主类 如果主类的包名是net.zlogs，那么主类的字节码一定存放在…\\net\\zlogs目录中，运行时必须到net\\zlogs的上一层（即net的父目录）目录中去运行主类。 假设net\\zlogs的上一层目录是1000，那么，必须如下格式来运行： C:\\1000\\java net.zlogs.主类名 import 语句 java包 一个类可能需要另一个类声明的对象作为自己的成员或方法中的局部变量，如果这两个类在同一个包中，当然没有问题。 (在同一个包中即有完全相同的父目录，不用import语句，而且net目录下的和net\\zlogs目录下的无父子关系，完全独立的两个包) 如果一个类想要使用的那个类和它不在一个包中，要使用import语句完成使命。如果用户需要类库中的类就可以使用import语句。 例如： import java.until.Date; 表示引入java.util包中的Date类 . 例如： import java.util.*；表示引入java.util包中所有的类 系统自动引入java.lang包中的所有类，java.lang包含所有基本语言类 引入自定义包中的类 用户程序也可以使用import语句引入非类库中有包名的类，如： import net.zlogs.*; 在用户程序所在目录下建立和包相对应的子目录结构，比如用户程序所在目录是C:\\ch4，想使用import语句引入net.zlogs包中的类，那么根据包名建立如下的目录结构： C:\\ch4\\net\\zlogs 如果用户不希望更新classpath的值，一个简单、常用的办法是：把程序使用的自定义的包名所形成的目录都放在同一文件夹中. "},"page/1041.html":{"url":"page/1041.html","title":"功能设计","keywords":"","body":"高级功能 "},"page/1036.html":{"url":"page/1036.html","title":"输入输出","keywords":"","body":"输入输出 "},"page/1037.html":{"url":"page/1037.html","title":"数据输入输出","keywords":"","body":"数据输入输出 输入基本型数据 可以使用Scanner类创建一个对象： Scanner reader=new Scanner(System.in); //其中：reader对象调用下列方法，读取用户在命令行输入的各种基本类型数据： nextBoolean()、 nextByte()、 nextShort()、 nextInt() 、nextLong()、nextFloat()、nextDouble()。 //上述方法执行时都会堵塞，程序等待用户在命令行输入数据回车确认。 输出基本型数据 java使用System类中的方法实现数据输出 例如：System.out.println()或System.out.print()输出串值，表达式的值。二者的区别是前者输出数据后换行，后者不换行。如： System.out.println(m+\"个数的和为\"+sum); System.out.println(\":\"+123+\"大于\"+122); 如果需要输出的字符串的长度较长，可以将字符串分解成几部分，然后使用并置符号：“+”将它们首尾相接， 例如：System.out.println(\"你好，\"+ \"很高兴认识你\" ); JDK1.5新增了和C语言中printf函数类似的输出数据的方法，格式如下： System.out.printf(\"格式控制部分\"，表达式1，表达式2，…表达式n) 格式控制部分由格式控制符号：%d、%c、%f、%s和普通的字符组成，普通字符原样输出。格式符号用来输出表达式的值。 %d输出int类型数据值；%c输出char型数据；%f输出浮点型数据，小数部分最多保留6位；%s输出字符串数据。 输出数据时也可以控制数据在命令行的位置，例如：%md输出的int型数据占m列；%m.nf输出的浮点型数据占m列，小数点保留n位。 例如：System.out.printf(\"%d,%f\",12, 23.78); "},"page/1038.html":{"url":"page/1038.html","title":"文件输入输出","keywords":"","body":"文件输入输出 "},"page/1045.html":{"url":"page/1045.html","title":"SQL","keywords":"","body":"SQL "},"page/1046.html":{"url":"page/1046.html","title":"网络","keywords":"","body":"网络 "},"page/1047.html":{"url":"page/1047.html","title":"线程","keywords":"","body":"线程 "},"page/1048.html":{"url":"page/1048.html","title":"异常机制","keywords":"","body":"异常机制 "},"page/1049.html":{"url":"page/1049.html","title":"GUI","keywords":"","body":"GUI "},"page/1138.html":{"url":"page/1138.html","title":"独有设计","keywords":"","body":"end "},"page/1042.html":{"url":"page/1042.html","title":"高级特性","keywords":"","body":"高级特性 "},"page/1139.html":{"url":"page/1139.html","title":"常用包","keywords":"","body":"常用包 "},"page/1169.html":{"url":"page/1169.html","title":"java.lang","keywords":"","body":"java.lang "},"page/1170.html":{"url":"page/1170.html","title":"基本类型的封装","keywords":"","body":"基本类型的封装 Java的基本数据类型包括 Java提供了基本数据类型相关的类，实现了对基本数据类型的封装。 Byte、Integer、Short、Long、Float、Double、Character类 这些类在java.lang包中。 Double和Float类 Double类和Float类实现了对double和float基本型数据的类包装。 Double类的构造方法：Double(double num) Float类的构造方法： Float(float num) Double对象调用doubleValue()方法可以返回该对象中含有的double型数据。 Float对象调用floatValue()方法可以返回该对象中含有的float型数据。 class Test { public static void main(String args[]) { String s1 = \"20\"; String s2 = \"80\"; System.out.println(s1 + s2); Double d1 = new Double(s1); Double d2 = new Double(s2); double m1 = d1.doubleValue(); double m2 = d1.doubleValue(); System.out.println(m1 + m2); } } /* 2080 40.0 */ Byte、Short 、Integer、Long类 上述类的构造方法分别 ： Byte(byte num) Short(short num) Integer(int num) Long(long num) Byte、Short、Integer和Long对象分别调用 byteValue ()、shortValue()、intValue()和longValue ()方法 返回该对象含有的基本型数据。 Character类 Character类实现了对char基本型数据的类包装。 Character类的构造方法：Character(char c) Character类中的一些常用类方法： public static boolean isDigit(char ch) ch是数字字符返回true. public static boolean isLetter(char ch) ch是字母返回 true。 "},"page/1043.html":{"url":"page/1043.html","title":"应用","keywords":"","body":"应用 "},"page/1999.html":{"url":"page/1999.html","title":"end1178","keywords":"","body":"end1141 "}}